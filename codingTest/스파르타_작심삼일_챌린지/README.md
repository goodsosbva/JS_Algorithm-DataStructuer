# 작심삼일 챌린지

#### !! 리드미 올리는 코드는 시니어 정답 코드
#### !! 파일로 올리는건 내가 낸 정답 코드

### 1. 소수 구하기 https://www.acmicpc.net/problem/1929
### 2. 안전 영역 https://www.acmicpc.net/problem/2468
- 스파르타 시니어 코드 <br />
```python
import sys
sys.setrecursionlimit(100000)
input = sys.stdin.readline

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(x, y, h):
    visited[x][y] = True
    for d in range(4):
        nx = x + dx[d]
        ny = y + dy[d]
        if 0 <= nx < n and 0 <= ny < n:
            if not visited[nx][ny] and graph[nx][ny] > h:
                dfs(nx, ny, h)

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]

max_height = max(map(max, graph))

max_safe_zone = 0
for h in range(0, max_height + 1):
    visited = [[False] * n for _ in range(n)]
    safe_zone_count = 0

    for i in range(n):
        for j in range(n):
            if not visited[i][j] and graph[i][j] > h:
                dfs(i, j, h)
                safe_zone_count += 1

    max_safe_zone = max(max_safe_zone, safe_zone_count)

print(max_safe_zone)
```
### 3. 저울 https://www.acmicpc.net/problem/2437
🔍 접근 방법 (시니어 설명) <br />
이 문제는 그리디 알고리즘을 기반으로 한 대표적인 아이디어 문제야.

문제를 보면, 여러 개의 추가 주어지고 이걸로 측정할 수 없는 가장 작은 무게를 찾으라고 하지?

이때 중요한건 모든 조합을 구해서 가능한 무게를 다 만들어보는 게 아니라, 가장 작은 수부터 하나씩 쌓아가면서 만들 수 있는 범위를 확장해 가는 방식이 훨씬 효율적이라는걸 생각해야 한다는 것이야.

핵심 포인트:

- 입력된 추들을 오름차순으로 정렬
- 현재까지 만들 수 있는 모든 무게의 최대값을 target이라고 가정
- 다음 추가 target보다 작거나 같으면 → 기존 범위에 이어서 측정 가능
- 추가 target보다 크면 → 그 순간의 target이 만들 수 없는 최소 무게가 된다!

접근 방법:

1. 입력된 무게 리스트를 오름차순으로 정렬해

2. target = 1부터 시작해, 현재까지 만들 수 있는 모든 무게 범위 [1, target)보다 큰 추가 나오면 break

3. 순회하면서 현재 추가 target보다 작거나 같으면, 해당 추를 더해서 target 범위를 키워줘

4. 만약 target보다 큰 추가 나온다면 거기서 break해주면돼. 그 순간이 우리가 찾는 답이 될거야!

주의사항:

- 정렬을 안 하면 답이 절대 안 나와! 항상 작은 값부터 순차적으로 처리해야 해
- target < 추의 무게 이 조건이 딱 걸리는 시점이 핵심 분기점이야 <br />
💻 풀이 코드 1 <br />
```python
n = int(input())
data = list(map(int, input().split()))
data.sort()

target = 1
for x in data:
    if target < x:
        break
    target += x

print(target)
```
📝 코드 설명 <br />
이 코드는 정렬 + 누적합 + 조건문만으로 문제를 해결할 수 있어.

처음에 target = 1로 시작하는 이유는, 기본적으로 1원을 만들 수 있는지 없는지부터 따져보기 위해서야.

이후 반복문을 돌면서, 현재 추(x)가 지금까지 만들 수 있는 범위보다 작거나 같으면 그걸 추가해서 target을 확장해줘.

예를들어서, target이 4인데 다음 추가 3이면 → 1~6까지 만들 수 있게 되는 거지!

반대로, 다음 추가 target보다 크면 → 그 추로는 target을 만들 수 없기 때문에, 거기서 바로 종료하면돼

결과적으로 반복이 끝났을 때의 target이 우리가 만들 수 없는 최소 무게가 되는 거야.
📊 복잡도 분석 <br />
시간 복잡도: O(n log n)
공간 복잡도: O(n)
⚡ 최적화 팁 <br />
1. 정렬우선: 가추를 작은 값부터 사용해야 그리디 전략이 제대로 작동할 수 있어
2. target 누적만으로 해결: 별도의 배열이나 조합 계산 없이, 누적합만으로 측정 가능한 범위를 관리할 수 있어
3. 빠른 종료 전략: target보다 큰 수가 나오면 바로 종료하면 되니까, 불필요한 반복 없이 성능도 좋아
🎯 학습 포인트 <br />
- 그리디 알고리즘의 정렬 기반 접근은 필수로 알아둬야해
- 누적합과 비교를 활용한 범위 확장! 조합 계산 없이 문제를 해결할 수 있어!
- 조건문 하나로 절묘하게 분기되는 로직을 파악하는 감각 키우기
🔗 관련 문제
- 이런 유형은 “추”, “동전”, “무게” 같은 키워드가 나오면 정렬 + 누적합 + 그리디 조합을 떠올려야 해
- 가장 작은 경우부터 고려하며 조건을 점검하는 방식은 좋은 전략이야
- 문제 조건이 간단해 보이지만, 조합을 쓰면 시간 초과 나고 그리디로 풀면 한 줄 조건문으로 깔끔하게 풀리는 문제라는 걸 익혀두면 실전에서 시간 아낄 수 있어


### 6. JadenCase 문자열 만들기 https://school.programmers.co.kr/learn/courses/30/lessons/12951?language=python3
#### 시니어 코드
💻 풀이 코드 1 <br />
```python
def solution(s):
    slist = s.split(' ')  # 공백을 기준으로 문자열을 단어로 나눕니다.
    for i in range(len(slist)):
        slist[i] = slist[i].capitalize()  # 각 단어의 첫 글자를 대문자로 바꿉니다.
    result = ' '.join(slist)  # 다시 공백을 기준으로 단어들을 합칩니다.
    return result
```
📝 코드 설명
먼저 문자열을 ' ' 기준으로 split해서 단어 리스트를 만들어줘

이때 공백이 여러 개일 경우 빈 문자열('')도 리스트에 포함돼

각 단어에 대해 capitalize()를 적용하면, 첫 글자는 대문자, 나머지는 자동으로 소문자로 전환돼

단어가 빈 문자열이면 capitalize()는 그냥 빈 문자열을 그대로 반환하므로 안전하다!

모든 단어를 변환한 뒤에는 ' '.join()을 통해 다시 하나의 문자열로 붙여줘

이 과정을 통해 공백 위치까지 원래대로 유지되며, 원하는 결과가 나오면 끝!
📊 복잡도 분석 <br />
시간 복잡도: O(N)
공간 복잡도: O(N)
⚡ 최적화 팁
1. [공백 유지]: ' '.join()을 사용하면 split할 때 생긴 공백 구조를 자연스럽게 되살릴 수 있어
2. [빈 문자열 처리]: 빈 문자열에 capitalize()를 적용해도 에러가 나지 않으므로 따로 조건 분기 필요가 없다~
3. [메서드 활용]: 직접 구현하지 말고 capitalize()를 적극 활용하면 훨씬 깔끔하다
🎯 학습 포인트 <br />
- 문자열에서 단어별로 특정 포맷을 적용하는 방법은 여러가지이니까 도전해봐
- split-join 패턴의 유용성을 익혀봐
- 문자열 메서드 capitalize()는 기본이니 꼭 알아두자
🔗 관련 문제
- 문자열 조작 문제에서는 split과 join으로 공백 문제를 깔끔히 다룰 수 있다
- 연속된 공백이나 앞뒤 공백을 보존해야 할 때는 반드시 split(’ ’)처럼 명시적 구분자를 써야 함을 잊지말자
- 문자열 포맷팅은 직접 구현보다 내장 메서드를 활용하는 게 훨씬 안정적이고 빠르다!

### 8. 나의 인생에는 수학과함께 https://www.acmicpc.net/problem/17265
동적 계획법
🔍 접근 방법 <br />
이 문제는 2차원 격자를 DFS로 완전탐색하며 모든 경로의 결과값을 계산하는 문제야

**핵심 포인트:**

- 홀수/짝수 칸의 역할 구분하기 (숫자 / 연산자)
- 숫자 → 연산자 → 숫자 순서대로 진행하기
- DFS로 모든 가능한 연산 결과를 탐색하기

**접근 방법:**

1. 시작점 (0,0)에서 출발해 오른쪽 또는 아래 방향으로만 이동
2. 현재 위치가 숫자라면 그대로 전달, 연산자라면 다음 숫자와 함께 연산
3. 도착점에 도달했을 때 최댓값과 최솟값을 각각 갱신

**주의사항:**

- 숫자와 연산자의 위치가 번갈아 나타나는 패턴을 반드시 지키기
- 연산 순서가 뒤섞이지 않도록 주의하자

💻 풀이 코드 1 <br />
```python
import sys

ap = -sys.maxsize
an = sys.maxsize

def DFS(y, x, p):
    global ap, an
    if y == n - 1 and x == n - 1:
        ap = max(ap, p)
        an = min(an, p)
        return

    for i in range(2):
        yy, xx = y + dy[i], x + dx[i]
        if yy == n or xx == n:
            continue

        if arr[y][x] == '*':
            DFS(yy, xx, p * arr[yy][xx])
        elif arr[y][x] == '+':
            DFS(yy, xx, p + arr[yy][xx])
        elif arr[y][x] == '-':
            DFS(yy, xx, p - arr[yy][xx])
        else:
            DFS(yy, xx, p)

n = int(input())
arr = [list(map(str, input().split())) for _ in range(n)]

dy = [0, 1]
dx = [1, 0]

for i in range(n):
    for j in range(n):
        if (i + j) % 2 == 0:
            arr[i][j] = int(arr[i][j])

DFS(0, 0, arr[0][0])
print(ap, an)
```

📝 코드 설명 <br />
우선 sys.maxsize를 이용해 초기 최댓값 ap와 최솟값 an을 설정해줘

이 값들은 모든 경로를 탐색하면서 갱신될 대상이야

DFS 함수는 현재 위치 (y, x)와 지금까지 계산된 값 p를 인자로 받아

목표 위치 (n-1, n-1)에 도달하면, 그때까지 계산된 값 p를 최대값/최솟값 후보로 갱신하고 종료

이후 두 방향(오른쪽, 아래쪽)으로 이동하면서 재귀적으로 DFS를 진행해줘

현재 위치에 있는 값이 연산자라면, 다음 숫자칸과 연산을 수행한 값을 넘기면서 DFS를 이어가고, 숫자라면 그대로 값을 넘겨줘

입력에서 숫자는 (x+y) 합이 짝수인 칸에만 오므로,

arr 배열을 순회하면서 그런 칸에 있는 문자열을 정수형으로 바꿔주면돼

마지막으로 (0, 0)에서 시작하여 모든 경로를 탐색한 후, 최대값과 최소값을 출력하면 끝!
📊 복잡도 분석 <br />
시간 복잡도: O(2^(2n))
공간 복잡도: O(n^2)
⚡ 최적화 팁
1. 수행 순서 관리하기:연산자와 숫자가 교대로 나타나므로 위치에 따라 형식을 미리 처리해두면 연산 분기 처리가 쉬워진다!
2. DFS 가지치기:중간에 불필요한 연산 가지치기를 통해 시간 단축
3. 입력 처리 최적화하기:숫자만 미리 int로 바꿔두는 전처리 필수!
🎯 학습 포인트 <br />
- 2차원 격자에서도 DFS가 유효하게 쓰일 수 있다는 점을 학습하기
- 연산이 포함된 경로 탐색 문제에서는 값을 인자로 넘기는 방식으로 관리해준다
- 홀짝 위치를 이용한 조건 분기 아이디어 생각하기!

### 보너스1 - 과자 나눠주기 - https://www.acmicpc.net/problem/16401
[이분탐색]
🔍 접근 방법 <br />
문제 자체는 이해하기 쉬워.

조카 M명에게 과자 N개를 나눠주려고 하는데,

과자는 자를 수 있고 모든 조카에게 길이가 같은 과자 하나씩 주고 싶을 때,

가장 길게 나눠줄 수 있는 최대 길이는? 이라고 이해하면될거같아.

처음엔 그냥 나눠보는 식으로 접근할 수 있겠지만,

이건 가능한 길이를 기준으로 탐색하는 전형적인 이분 탐색 문제라고 볼 수 있지.

핵심 포인트:

- 길이를 기준으로 가능한지 확인하는 결정
- 탐색 대상: 길, 조건: 길이 x로 잘랐을 때 M명 이상에게 줄 수 있는가
- 조건을 만족하는 최대 길이를 찾는 것이 우리의 목적!

접근 방법:

1. 과자 길이 리스트를 받고, 탐색 범위를 1 ~ 최대 과자 길이로 설정하기
2. 중간값(mid)을 기준으로 과자들을 나눠봤을 때,

총 몇 명에게 줄 수 있는지를 계산해봐

1. 만약 조카 수 이상 줄 수 있다면 → 가능한 더 긴 길이가 있을 수 있으니 오른쪽 탐색
2. 못 주면 → 길이가 너무 길었다는 뜻 → 왼쪽 탐색
3. 그 과정을 반복해서 가능한 최대 길이를 이분 탐색으로 찾아내면돼!

주의사항:

- 과자의 길이가 0이 될 수는 없는거 이해하지? 탐색 시작을 start = 1로 설정해야해
- M명이 많을수록, 길이는 작아질 가능성이 높다를 기억해둬


💻 풀이 코드 1 <br />
```python
M, N = map(int, input().split())
ls = list(map(int, input().split()))

def binary_search(array):
    min = 1
    end = max(ls)

    while min <= end:
        cnt = 0
        mid = (min + end) // 2

        for cookie in ls:
            cnt += cookie // mid

        if cnt >= M:
            min = mid + 1
        else:
            end = mid - 1

    return end

print(binary_search(ls))
```

📝 코드 설명 <br />
먼저 입력을 받고, 이분 탐색을 위한 시작점(start=1)과 끝점(end=max(ls))을 잡아줘.

그다음 mid값을 과자의 길이 후보로 생각하고,

모든 과자를 해당 길이로 잘랐을 때 몇 개 나오는지를 확인해.

이렇게 잘라서 나온 조각 수가 M명 이상이면

이 길이로 나눠줄 수 있네?라고 생각을 할수 있고,

그러면 더 길게도 나눠줄 수 있을지 시도해보는 거고,

반대로 부족하면 길이가 너무 길었다는 의미니까 길이를 줄여.

이걸 반복해서 탐색을 좁혀가면 결국

조건을 만족하는 가장 긴 길이가 최종 정답을 구할 수 있어.
📊 복잡도 분석 <br />
시간 복잡도: O(N log L)
공간 복잡도: O(N)
⚡ 최적화 팁
1. 초기 탐색 범위 설정: start = 1, end = max(과자 길이)
2. 카운팅 방식 최적화: cookie / mid → 나눠질 수 있는 조각 수 빠르게 계산
3. 조건 판단: >= M일 때만 길이를 늘리자 (우측 탐색)
🎯 학습 포인트 <br />


- 이분 탐색은 꼭 정렬된 배열에만 쓰는 게 아니다!→ 이렇게 정답의 범위가 연속된 수일 때도 잘 쓰여
- 결정 문제 형태로 바꿔서 탐색하는 패턴 이해해야해
- mid가 정답이 아닐 수도 있다는 점 유의하기
🔗 관련 문제
- “가장 크거나 작게”, “최대 길이”, “최소 비용”처럼 ~할 수 있는 최대/최소값을 구하라가 나온다면→ 이분 탐색을 떠올려 보기!
- 가능한가 아닌가를 판단하는 조건을 정확하게 만들어야해
- 실수 연산을 쓰지 않고, 정수 연산으로 정밀하게 계산하는 습관을 들이는것이 다른 문제들을 풀때도 도움이 될거야

### 보너스 2 - CD - https://www.acmicpc.net/problem/4158

set 교집합 연산으로 빠르게 겹치는 CD 찾기


🔍 접근 방법 <br />
이 문제는 "A와 B가 각각 가진 CD 목록 중, 겹치는 CD가 몇 개인지를 구하라"는 문제야.
여기서 핵심은:

CD 수는 최대 1,000,000장.

정렬되어 주어지는 것도 아니고, 그냥 쭉 입력됨.

그러니까 정렬+이진탐색을 쓰거나, 해시 기반 집합 연산을 써야 해.

우리가 사용한 이 코드는 바로 두 개의 set을 만들어놓고,
서로의 교집합을 이용해서 겹치는 CD 개수를 구하는 구조야.

파이썬에선 set 자료구조가 해시 기반이라
원소 하나를 찾는 데 O(1) 이렇게 처리하는 게 매우 효율적이지.
💻 풀이 코드 1 <br />

```python
import sys
input=sys.stdin.readline
while True:
    n,m=map(int,input().split())
    cd_n={int(input()) for _ in range(n)}
    cd_m={int(input()) for _ in range(m)}
    if n==0 and m==0:
        break
    print(len(cd_n&cd_m))
```

📝 코드 설명 <br />
- 여기서는 두 입력을 `set`으로 받아서 교집합 연산(`&`)을 사용하죠.
- Python의 `set`은 내부적으로 해시 테이블로 구현돼 있어서,
- 원소 삽입/탐색/삭제 모두 평균 시간복잡도가 **O(1)**입니다.
- 교집합 연산도 내부적으로 빠르게 처리됩니다.
📊 복잡도 분석 <br />
시간 복잡도: O(n log n) or O(n log m)
공간 복잡도: O(n)
⚡ 최적화 팁
1. 교집합은 파이썬이 다 해준다, set1 & set2 한 줄이면 교집합 개수를 바로 구할 수 있다. 반복문이나 이진 탐색도 필요 없다
2. 중복 자동 제거 덕에 따로 정렬이 필요 없다
3. 불필요한 계산을 줄이려면 종료 조건 먼저 확인, if n == 0 and m == 0: break 는 입력 읽기 전에 넣는 게 조금 더 안전하지만, 이 풀이에서는 어차피 모든 입력을 다 받고 나서 비교하니 성능 상 문제가 없다

[Practical Tips]
- 알고리즘 문제 풀 때는 항상 자료 구조부터 고민
- 면접에서는 왜 set을 썼는지 설명, 무조건 빠르니까 썼다가 아니라, 중복 제거, 교집합 연산, 평균 시간복잡도 O(1)조회 성능
🎯 학습 포인트 <br />


- set 연산의 강력함
- 같은 문제라도 리스트로 풀면 O(nlogn)이나 O(n^2)이지만, set으로 바꾸면 O(n)수준까지도 줄어든다.
- 간결함과 성능의 균형: 파이썬의 고급 문법은 성능과 코드 간결함을 동시에 잡을 수 있게 해준다.
